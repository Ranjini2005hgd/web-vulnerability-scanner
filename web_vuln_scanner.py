
import requests
import ssl
import socket
from urllib.parse import urlparse

# Function to fetch a webpage
def fetch_page(url):
    try:
        response = requests.get(url)
        if response.status_code == 200:
            return response.text
        else:
            return f"Failed to fetch page: {response.status_code}"
    except requests.exceptions.RequestException as e:
        return f"An error occurred: {e}"

# SQL Injection Check
def check_sql_injection(url):
    payload = "' OR '1'='1"
    test_url = url + ('?' if '?' in url else '?') + payload
    response = requests.get(test_url)
    if "error" in response.text.lower() or "mysql" in response.text.lower():
        return "Vulnerable to SQL Injection: An attacker can manipulate SQL queries to gain unauthorized access to data."
    return None

# XSS Check
def check_xss(url):
    payload = "<script>alert('XSS')</script>"
    test_url = url + ('?' if '?' in url else '?') + "test=" + payload
    response = requests.get(test_url)
    if payload in response.text:
        return "Vulnerable to XSS (Cross-Site Scripting): An attacker can inject malicious scripts into webpages viewed by others."
    return None

# Directory Listing Check
def check_directory_listing(url):
    response = requests.get(url)
    if "Index of /" in response.text or "directory listing" in response.text.lower():
        return "Directory Listing is Enabled: Sensitive files or directories might be exposed to unauthorized users."
    return None

# Directory Traversal Check
def check_directory_traversal(url):
    payload = "/../../etc/passwd"
    test_url = url + payload
    response = requests.get(test_url)
    if "root:" in response.text:
        return "Vulnerable to Directory Traversal: An attacker can access files and directories outside the intended directory."
    return None

# Open Redirect Check
def check_open_redirect(url):
    payload = "/redirect?url=http://malicious.com"
    test_url = url + payload
    response = requests.get(test_url)
    if "http://malicious.com" in response.url:
        return "Vulnerable to Open Redirects: An attacker can redirect users to malicious websites."
    return None

# Insecure Cookies Check
def check_insecure_cookies(url):
    response = requests.get(url)
    insecure_cookies = []
    for cookie in response.cookies:
        if not cookie.secure:
            insecure_cookies.append(f"Cookie {cookie.name} is not secure: It is sent over unencrypted connections.")
        if not cookie.has_nonstandard_attr('HttpOnly'):
            insecure_cookies.append(f"Cookie {cookie.name} is not HttpOnly: It can be accessed via client-side scripts.")
    if insecure_cookies:
        return "\n".join(insecure_cookies)
    return None

# SSL/TLS Issues Check
def check_ssl_tls(url):
    hostname = urlparse(url).hostname
    context = ssl.create_default_context()
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
    try:
        with socket.create_connection((hostname, 443)) as sock:
            with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                tls_version = ssock.version()
                if tls_version in ["TLSv1", "SSLv2", "SSLv3"]:
                    return f"Outdated SSL/TLS version detected: {tls_version}. These versions have known vulnerabilities and should be updated."
    except Exception as e:
        return f"SSL/TLS check failed: {e}"
    return None

# Content Security Policy (CSP) Check
def check_csp(url):
    response = requests.get(url)
    csp = response.headers.get("Content-Security-Policy", "")
    if not csp:
        return "No Content Security Policy (CSP) header found: CSP helps prevent cross-site scripting and other code injection attacks."
    elif "unsafe-inline" in csp or "unsafe-eval" in csp:
        return "CSP contains unsafe directives: Directives like 'unsafe-inline' or 'unsafe-eval' can lead to XSS vulnerabilities."
    return None

# Clickjacking Check
def check_clickjacking(url):
    response = requests.get(url)
    if 'X-Frame-Options' not in response.headers:
        return "Website is vulnerable to clickjacking (missing X-Frame-Options header): An attacker can trick users into clicking on something different from what they perceive."
    return None

# Information Disclosure Check
def check_information_disclosure(url):
    response = requests.get(url)
    if "Error" in response.text or "warning" in response.text.lower():
        return "Potential information disclosure detected: Error messages may reveal sensitive information about the application or server."
    return None

# Public Admin Access Check
def check_admin_access(url):
    potential_admin_paths = ["/admin", "/administrator", "/admin/login", "/wp-admin"]
    found_admin_pages = []
    for path in potential_admin_paths:
        test_url = url + path
        response = requests.get(test_url)
        if response.status_code == 200 and "login" in response.text.lower():
            found_admin_pages.append(f"Admin page found: {test_url}. Publicly accessible admin pages may allow unauthorized access.")
    if found_admin_pages:
        return "\n".join(found_admin_pages)
    return None

# Insecure HTTP Methods Check
def check_insecure_http_methods(url):
    methods = ['DELETE', 'PUT', 'PATCH', 'OPTIONS']
    insecure_methods = []
    for method in methods:
        try:
            response = requests.request(method, url)
            if response.status_code not in [405, 403]:
                insecure_methods.append(f"HTTP Method {method} allowed: The server accepts potentially dangerous methods.")
        except requests.exceptions.RequestException:
            continue
    if insecure_methods:
        return "\n".join(insecure_methods)
    return None

# Security Headers Check
def check_security_headers(url):
    response = requests.get(url)
    headers = response.headers
    issues = []
    required_headers = {
        "Strict-Transport-Security": "Missing or misconfigured HSTS header: This header helps prevent man-in-the-middle attacks by enforcing HTTPS.",
        "X-Content-Type-Options": "Missing or misconfigured X-Content-Type-Options header: This header prevents MIME type sniffing.",
        "X-XSS-Protection": "Missing or misconfigured X-XSS-Protection header: This header provides basic protection against XSS attacks."
    }
    for header, message in required_headers.items():
        if header not in headers:
            issues.append(message)
    if issues:
        return "\n".join(issues)
    return None

# Report Generation
def generate_report(url, vulnerabilities):
    report_path = "scan_report.txt"
    try:
        with open(report_path, "w") as report:
            report.write(f"Scan results for {url}:\n")
            if vulnerabilities:
                for vulnerability in vulnerabilities:
                    report.write(f"{vulnerability}\n")
            else:
                report.write("No vulnerabilities found.\n")
        print(f"Scan complete. Results saved to {report_path}.")
    except Exception as e:
        print(f"Failed to save report: {e}")

# Main Function
if __name__ == "__main__":
    url = input("Enter the URL to scan: ")
    vulnerabilities = []

    print("Checking for SQL Injection...")
    sql_injection_issue = check_sql_injection(url)
    if sql_injection_issue:
        vulnerabilities.append(sql_injection_issue)

    print("Checking for XSS...")
    xss_issue = check_xss(url)
    if xss_issue:
        vulnerabilities.append(xss_issue)

    print("Checking for Directory Listing...")
    directory_listing_issue = check_directory_listing(url)
    if directory_listing_issue:
        vulnerabilities.append(directory_listing_issue)

    print("Checking for Directory Traversal...")
    directory_traversal_issue = check_directory_traversal(url)
    if directory_traversal_issue:
        vulnerabilities.append(directory_traversal_issue)

    print("Checking for Open Redirects...")
    open_redirect_issue = check_open_redirect(url)
    if open_redirect_issue:
        vulnerabilities.append(open_redirect_issue)

    print("Checking for Insecure Cookies...")
    insecure_cookies = check_insecure_cookies(url)
    if insecure_cookies:
        vulnerabilities.append(insecure_cookies)

    print("Checking for SSL/TLS Issues...")
    ssl_issue = check_ssl_tls(url)
    if ssl_issue:
        vulnerabilities.append(ssl_issue)

    print("Checking for CSP...")
    csp_issue = check_csp(url)
    if csp_issue:
        vulnerabilities.append(csp_issue)

    print("Checking for Clickjacking...")
    clickjacking_issue = check_clickjacking(url)
    if clickjacking_issue:
        vulnerabilities.append(clickjacking_issue)

    print("Checking for Information Disclosure...")
    info_disclosure = check_information_disclosure(url)
    if info_disclosure:
        vulnerabilities.append(info_disclosure)

    print("Checking for Public Admin Access...")
    admin_access = check_admin_access(url)
    if admin_access:
        vulnerabilities.append(admin_access)

    print("Checking for Insecure HTTP Methods...")
    insecure_methods = check_insecure_http_methods(url)
    if insecure_methods:
        vulnerabilities.append(insecure_methods)

    print("Checking for Security Headers...")
    security_headers_issues = check_security_headers(url)
    if security_headers_issues:
        vulnerabilities.append("security_headers_")
    print("Checking for Security Headers...")
    security_headers_issues = check_security_headers(url)
    if security_headers_issues:
        vulnerabilities.append(security_headers_issues)

    print("Vulnerabilities found:", vulnerabilities)  # Debugging line
    generate_report(url, vulnerabilities)
